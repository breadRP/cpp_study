# C++ 메모리 / 복사 / 포인터 / 소유권 개념 총정리

> 이 문서는 C++ 객체 복사, 포인터, 얕은 복사, 깊은 복사, 소유권 개념을 **완전히 이해하기 위한 복습용 정리 문서**입니다.
> (기초 → 내부 원리 → 실무 관점 순서)

---

# 1. 변수 종류와 메모리 구조

## 1.1 일반 변수

```cpp
int a = 10;
```

메모리:

```
a → 10
```

→ 값 저장

---

## 1.2 포인터 변수

```cpp
int* p = &a;
```

메모리:

```
p → a의 주소
```

→ 주소 저장

---

## 1.3 객체 변수

```cpp
class A { int x; };
A obj;
```

객체는:

```
obj → 메모리 블록
        x
```

즉:

> 객체 = 멤버 변수 저장 공간

---

# 2. 복사 개념 핵심

객체 복사하면:

```
객체 메모리 → 새로 생성됨
멤버 변수 값 → 복사됨
```

---

# 3. 자동 복사의 실제 동작 원리

컴파일러가 자동 생성하는 복사 생성자 내부 동작 개념:

```cpp
A(const A& other){
    x = other.x;
    p = other.p;
}
```

즉:

> 멤버 단위 복사 (member-wise copy)

---

# 4. 얕은 복사 vs 깊은 복사

---

## 4.1 얕은 복사 (Shallow Copy)

```cpp
b.p = a.p;
```

결과:

```
같은 주소 공유
```

메모리:

```
a.p ─┐
     ├──> 데이터
b.p ─┘
```

문제 가능:

* double delete
* dangling pointer
* 메모리 충돌

---

## 4.2 깊은 복사 (Deep Copy)

```cpp
p = new int(*other.p);
```

결과:

```
서로 다른 주소
같은 값
```

메모리:

```
a.p → 10
b.p → 10
```

---

## 핵심 차이 한 줄

```
얕은 복사 = 주소 복사
깊은 복사 = 값 복사 + 새 메모리 생성
```

---

# 5. 왜 컴파일러는 깊은 복사를 안 해주나?

컴파일러는 모른다:

* 몇 개 생성해야 하는지
* 배열인지
* 타입이 뭔지

그래서 기본 규칙:

> 컴파일러는 절대 추측하지 않는다 → 값만 복사

---

# 6. 진짜 문제의 원인

많은 사람들이 착각:

```
포인터 있어서 문제 ❌
```

진짜 원인:

```
소유권 설계 없음 ✔
```

---

## 핵심 공식

```
주소 공유 + 둘 다 delete
= 오류
```

---

# 7. 소유권 (Ownership) 개념 ⭐

C++ 메모리 관리 핵심 개념:

> 누가 메모리 주인인가?

종류:

| 종류    | 의미           |
| ----- | ------------ |
| 단일 소유 | 한 객체만 delete |
| 공유 소유 | 마지막만 delete  |
| 비소유   | delete 안 함   |

---

# 8. double delete vs dangling pointer

---

## double delete

같은 메모리를 두 번 delete

---

## dangling pointer

이미 delete된 주소를 계속 들고 있음

```cpp
delete p;
// p 아직 주소 가지고 있음 → 위험
```

해결:

```cpp
p = nullptr;
```

---

# 9. new 의 정확한 역할

많은 오해:

```
new = 값 복사 ❌
```

정답:

```
new = 메모리 생성 ✔
```

값 복사는 여기서 발생:

```
*other.p
```

---

### 한 줄 정리

```
new → 공간 생성
*ptr → 값 읽기
```

---

# 10. 복사 생성자 / 대입 연산자의 진짜 역할

오해:

```
복사 생성자가 문제다 ❌
```

정답:

> 복사 함수는 문제 해결 도구다 ✔

---

### 자동 생성 복사 함수

→ 얕은 복사

### 직접 작성 복사 함수

→ 원하는 방식 복사 가능

---

# 11. Rule of 3

다음 중 하나 있으면 셋 다 작성:

* 소멸자
* 복사 생성자
* 대입 연산자

조건:

> 클래스가 자원을 직접 관리할 때

---

# 12. malloc/free 와 완전 동일한 문제

C 스타일:

```c
int* p = malloc(...);
int* q = p;
free(p);
free(q); // 오류
```

C++ 스타일:

```cpp
A a;
A b = a;
```

본질:

```
같은 메모리 두 번 해제
```

---

# 13. 스마트 포인터 등장 이유

raw pointer 문제 해결용.

---

## 종류

### unique_ptr

→ 단독 소유

### shared_ptr

→ 공동 소유 (참조 카운트)

### weak_ptr

→ 관찰용

---

## 선택 기준

```
소유 → smart pointer
비소유 → raw pointer / reference
```

---

# 14. 안전한 설계 기준

항상 스스로에게 물어야 하는 질문:

> 이 메모리 누가 delete 하지?

답 못 하면 버그 발생.

---

# 15. 진짜 핵심 요약 ⭐⭐⭐

### 반드시 기억

```
자동 복사 = 멤버 값 그대로 복사
포인터 멤버 있으면 = 주소 공유
문제 원인 = 소유권 충돌
해결 = 복사 정책 직접 정의
```

---

# 16. 최종 핵심 한 문장

> C++ 메모리 문제는 포인터 때문이 아니라 소유권 설계 때문이다.

---

# 17. 실무 레벨 핵심 직관

```
주소 공유 = 문제 아님
삭제 책임 불명확 = 문제
```

---

# 18. 최종 이해 체크 질문 (복습용)

스스로 답해보기:

1. 얕은 복사와 깊은 복사 차이?
2. 컴파일러는 왜 깊은 복사를 안 해주나?
3. double delete 발생 조건?
4. dangling pointer 정의?
5. smart pointer 쓰는 기준?

이 다 답할 수 있으면:

> C++ 메모리 모델 이해 완료

---

# END
